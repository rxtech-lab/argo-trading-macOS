<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #chart-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            display: none;
            padding: 10px 14px;
            background: rgba(30, 30, 30, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .tooltip-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        .tooltip-icon {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tooltip-icon.buy { color: #26a69a; }
        .tooltip-icon.sell { color: #ef5350; }
        .tooltip-title { font-weight: 600; font-size: 13px; }
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            margin: 4px 0;
        }
        .tooltip-label { color: #888; }
        .tooltip-value { font-family: 'SF Mono', Monaco, monospace; font-size: 11px; }
        .tooltip-reason {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid rgba(255,255,255,0.1);
            color: #aaa;
            font-size: 11px;
        }
        .pnl-positive { color: #26a69a; }
        .pnl-negative { color: #ef5350; }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 14px;
        }
    </style>
    <script src="trading://lightweight-charts.standalone.production.js"></script>
</head>
<body>
    <div id="chart-container">
        <div class="loading" id="loading">Loading chart...</div>
    </div>
    <div id="tooltip" class="tooltip"></div>

    <script>
        // Helper to send messages to Swift (defined first for console override)
        function postMessage(type, data) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[type]) {
                window.webkit.messageHandlers[type].postMessage(data);
            }
        }

        // Override console to send logs to Swift
        (function() {
            const originalConsole = {
                log: console.log.bind(console),
                warn: console.warn.bind(console),
                error: console.error.bind(console)
            };

            function sendToSwift(level, args) {
                const message = args.map(arg =>
                    typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
                ).join(' ');
                postMessage('consoleLog', { level: level, message: message });
            }

            console.log = function(...args) {
                originalConsole.log(...args);
                sendToSwift('log', args);
            };
            console.warn = function(...args) {
                originalConsole.warn(...args);
                sendToSwift('warn', args);
            };
            console.error = function(...args) {
                originalConsole.error(...args);
                sendToSwift('error', args);
            };
        })();

        // Global state
        let chart = null;
        let series = null;
        let currentChartType = 'Candlestick';
        let allMarkers = [];
        let tradeMarkers = [];
        let markMarkers = [];
        let dataMap = new Map(); // Map time -> { globalIndex, data }
        let isInitialized = false;

        // Throttle state for scroll events
        let lastScrollEventTime = 0;
        let pendingScrollEvent = null;
        let scrollThrottleMs = 200; // Only send scroll events at most every 200ms

        // Store original marker data for tooltips
        let markerDataMap = new Map(); // Map markerId -> full marker data

        // Initialize chart with options
        function initializeChart(chartType) {
            const container = document.getElementById('chart-container');
            document.getElementById('loading').style.display = 'none';

            currentChartType = chartType;

            chart = LightweightCharts.createChart(container, {
                layout: {
                    background: { type: 'solid', color: 'transparent' },
                    textColor: '#888888',
                    attributionLogo: false,
                },
                grid: {
                    vertLines: { color: 'rgba(42, 46, 57, 0.5)' },
                    horzLines: { color: 'rgba(42, 46, 57, 0.5)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                    vertLine: {
                        color: 'rgba(224, 227, 235, 0.1)',
                        width: 1,
                        style: 0,
                        labelBackgroundColor: '#2B2B43',
                    },
                    horzLine: {
                        color: 'rgba(224, 227, 235, 0.1)',
                        width: 1,
                        style: 0,
                        labelBackgroundColor: '#2B2B43',
                    },
                },
                rightPriceScale: {
                    borderColor: 'rgba(197, 203, 206, 0.3)',
                    scaleMargins: { top: 0.1, bottom: 0.1 },
                },
                timeScale: {
                    borderColor: 'rgba(197, 203, 206, 0.3)',
                    timeVisible: true,
                    secondsVisible: false,
                    minBarSpacing: 10,
                    maxBarSpacing: 13,
                },
                handleScale: {
                    mouseWheel: true,
                    pinch: true,
                    axisPressedMouseMove: true,
                },
                handleScroll: {
                    mouseWheel: true,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: false,
                },
            });

            // Create series based on type (v4+ API)
            if (chartType === 'Candlestick') {
                series = chart.addSeries(LightweightCharts.CandlestickSeries);
                series.applyOptions({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                });
            } else {
                series = chart.addSeries(LightweightCharts.LineSeries);
                series.applyOptions({
                    color: '#2196F3',
                    lineWidth: 2,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: 4,
                });
            }

            // Subscribe to visible range changes for infinite scroll (throttled)
            chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => {
                if (logicalRange === null) return;

                const now = Date.now();
                const eventData = { from: logicalRange.from, to: logicalRange.to };

                // Throttle: only send events at most every scrollThrottleMs
                if (now - lastScrollEventTime >= scrollThrottleMs) {
                    lastScrollEventTime = now;
                    pendingScrollEvent = null;
                    postMessage('visibleRangeChange', eventData);
                } else {
                    // Store pending event to send after throttle period
                    pendingScrollEvent = eventData;
                    setTimeout(() => {
                        if (pendingScrollEvent) {
                            lastScrollEventTime = Date.now();
                            postMessage('visibleRangeChange', pendingScrollEvent);
                            pendingScrollEvent = null;
                        }
                    }, scrollThrottleMs - (now - lastScrollEventTime));
                }
            });

            // Subscribe to crosshair move for OHLCV legend and tooltips
            chart.subscribeCrosshairMove(param => {
                handleCrosshairMove(param);
            });

            // Handle resize
            const resizeObserver = new ResizeObserver(entries => {
                if (entries.length > 0 && chart) {
                    const { width, height } = entries[0].contentRect;
                    chart.resize(width, height);
                }
            });
            resizeObserver.observe(container);

            isInitialized = true;
            postMessage('ready', { success: true });
        }

        // Handle crosshair movement
        function handleCrosshairMove(param) {
            const tooltip = document.getElementById('tooltip');

            if (!param.point || !param.time || param.point.x < 0 || param.point.y < 0) {
                tooltip.style.display = 'none';
                postMessage('crosshairMove', {
                    time: null,
                    price: null,
                    globalIndex: null,
                    ohlcv: null
                });
                return;
            }

            const seriesData = param.seriesData.get(series);
            if (!seriesData) return;

            const dataInfo = dataMap.get(param.time);
            const globalIndex = dataInfo ? dataInfo.globalIndex : null;

            // Build OHLCV data
            let ohlcv;
            if (seriesData.open !== undefined) {
                ohlcv = {
                    open: seriesData.open,
                    high: seriesData.high,
                    low: seriesData.low,
                    close: seriesData.close,
                    volume: dataInfo ? dataInfo.volume : 0
                };
            } else {
                ohlcv = {
                    open: seriesData.value,
                    high: seriesData.value,
                    low: seriesData.value,
                    close: seriesData.value,
                    volume: dataInfo ? dataInfo.volume : 0
                };
            }

            postMessage('crosshairMove', {
                time: param.time,
                price: seriesData.close || seriesData.value,
                globalIndex: globalIndex,
                ohlcv: ohlcv
            });

            // Check for marker hover
            checkMarkerHover(param);
        }

        // Check if hovering near a marker
        function checkMarkerHover(param) {
            const tooltip = document.getElementById('tooltip');
            const hoveredTime = param.time;

            // Find markers at or near this time
            const tolerance = 0; // Exact match for now

            for (const [markerId, markerData] of markerDataMap) {
                if (Math.abs(markerData.time - hoveredTime) <= tolerance) {
                    showMarkerTooltip(markerData, param.point);
                    return;
                }
            }

            // No marker found, hide tooltip
            tooltip.style.display = 'none';
        }

        // Show tooltip for a marker
        function showMarkerTooltip(markerData, point) {
            const tooltip = document.getElementById('tooltip');
            const container = document.getElementById('chart-container');
            const containerRect = container.getBoundingClientRect();

            let html = '';

            if (markerData.markerType === 'trade') {
                const isBuy = markerData.isBuy;
                const arrow = isBuy ? '&#9650;' : '&#9660;';
                const colorClass = isBuy ? 'buy' : 'sell';

                html = `
                    <div class="tooltip-header">
                        <div class="tooltip-icon ${colorClass}">${arrow}</div>
                        <div class="tooltip-title">${isBuy ? 'BUY' : 'SELL'}</div>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Symbol</span>
                        <span class="tooltip-value">${markerData.symbol || '-'}</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Position</span>
                        <span class="tooltip-value">${markerData.positionType || '-'}</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Date</span>
                        <span class="tooltip-value">${formatDate(markerData.time)}</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Qty</span>
                        <span class="tooltip-value">${formatNumber(markerData.executedQty, 4)}</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Price</span>
                        <span class="tooltip-value">${formatNumber(markerData.executedPrice, 2)}</span>
                    </div>
                `;

                if (!isBuy && markerData.pnl !== undefined) {
                    const pnlClass = markerData.pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
                    html += `
                        <div class="tooltip-row">
                            <span class="tooltip-label">PnL</span>
                            <span class="tooltip-value ${pnlClass}">${formatNumber(markerData.pnl, 2)}</span>
                        </div>
                    `;
                }

                if (markerData.reason) {
                    html += `<div class="tooltip-reason">${markerData.reason}</div>`;
                }
            } else if (markerData.markerType === 'mark') {
                html = `
                    <div class="tooltip-header">
                        <div class="tooltip-icon" style="color: ${markerData.color};">&#9679;</div>
                        <div class="tooltip-title">${markerData.title || 'Mark'}</div>
                    </div>
                `;

                if (markerData.category) {
                    html += `
                        <div class="tooltip-row">
                            <span class="tooltip-label">Category</span>
                            <span class="tooltip-value">${markerData.category}</span>
                        </div>
                    `;
                }

                if (markerData.signalType) {
                    html += `
                        <div class="tooltip-row">
                            <span class="tooltip-label">Signal</span>
                            <span class="tooltip-value">${markerData.signalType}</span>
                        </div>
                    `;
                }

                if (markerData.message) {
                    html += `<div class="tooltip-reason">${markerData.message}</div>`;
                }

                if (markerData.signalReason) {
                    html += `<div class="tooltip-reason">${markerData.signalReason}</div>`;
                }
            }

            tooltip.innerHTML = html;
            tooltip.style.display = 'block';

            // Position tooltip
            let left = point.x + 15;
            let top = point.y - 10;

            // Adjust if tooltip would go off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            if (left + tooltipRect.width > containerRect.width) {
                left = point.x - tooltipRect.width - 15;
            }
            if (top + tooltipRect.height > containerRect.height) {
                top = containerRect.height - tooltipRect.height - 10;
            }
            if (top < 10) top = 10;

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        // Format number
        function formatNumber(value, decimals) {
            if (value === undefined || value === null) return '-';
            return value.toFixed(decimals);
        }

        // Set candlestick data
        function setCandlestickData(data) {
            console.log('[Chart] setCandlestickData called with', data ? data.length : 0, 'items');
            if (!series) {
                console.error('[Chart] setCandlestickData: series is null');
                return;
            }
            if (!data || data.length === 0) {
                console.warn('[Chart] setCandlestickData: no data provided');
                return;
            }

            console.log('[Chart] First item:', JSON.stringify(data[0]));
            console.log('[Chart] Last item:', JSON.stringify(data[data.length - 1]));

            dataMap.clear();
            const formattedData = data.map(d => {
                dataMap.set(d.time, { globalIndex: d.globalIndex, volume: d.volume || 0 });
                return {
                    time: d.time,
                    open: d.open,
                    high: d.high,
                    low: d.low,
                    close: d.close
                };
            });

            console.log('[Chart] Setting', formattedData.length, 'candles to series');
            series.setData(formattedData);
            console.log('[Chart] Data set complete');
        }

        // Set line data
        function setLineData(data) {
            if (!series) return;

            dataMap.clear();
            const formattedData = data.map(d => {
                dataMap.set(d.time, { globalIndex: d.globalIndex, volume: d.volume || 0 });
                return {
                    time: d.time,
                    value: d.value
                };
            });

            series.setData(formattedData);
        }

        // Update single data point (for streaming)
        function updateCandlestickData(data) {
            if (!series) return;

            dataMap.set(data.time, { globalIndex: data.globalIndex, volume: data.volume || 0 });
            series.update({
                time: data.time,
                open: data.open,
                high: data.high,
                low: data.low,
                close: data.close
            });
        }

        // Update single line data point
        function updateLineData(data) {
            if (!series) return;

            dataMap.set(data.time, { globalIndex: data.globalIndex, volume: data.volume || 0 });
            series.update({
                time: data.time,
                value: data.value
            });
        }

        // Set markers (trades and marks)
        function setMarkers(markerData) {
            if (!series) return;

            markerDataMap.clear();
            tradeMarkers = [];
            markMarkers = [];

            markerData.forEach(m => {
                // Store full marker data for tooltip
                markerDataMap.set(m.id, m);

                const marker = {
                    time: m.time,
                    position: m.position,
                    color: m.color,
                    shape: m.shape,
                    text: m.text,
                    id: m.id
                };

                if (m.markerType === 'trade') {
                    tradeMarkers.push(marker);
                } else {
                    markMarkers.push(marker);
                }
            });

            updateVisibleMarkers();
        }

        // Update markers on the chart
        function updateVisibleMarkers() {
            if (!series) return;

            // Combine all markers and sort by time
            const allMarkers = [...tradeMarkers, ...markMarkers];
            allMarkers.sort((a, b) => a.time - b.time);

            series.setMarkers(allMarkers);
        }

        // Scroll to specific time
        function scrollToTime(timestamp) {
            if (!chart) return;
            chart.timeScale().scrollToPosition(-10, false);
        }

        // Set visible logical range
        function setVisibleRange(from, to) {
            if (!chart) return;
            chart.timeScale().setVisibleLogicalRange({ from: from, to: to });
        }

        // Resize chart
        function resizeChart(width, height) {
            if (!chart) return;
            chart.resize(width, height);
        }

        // Fit content to view
        function fitContent() {
            if (!chart) return;
            chart.timeScale().fitContent();
        }

        // Scroll to realtime (latest data)
        function scrollToRealtime() {
            if (!chart) return;
            chart.timeScale().scrollToRealTime();
        }

        // Get visible range (called from Swift to get current range)
        function getVisibleRange() {
            if (!chart) return null;
            return chart.timeScale().getVisibleLogicalRange();
        }

        // Switch chart type
        function switchChartType(newType) {
            if (!chart || currentChartType === newType) return;

            // Store current data
            const currentData = [];
            dataMap.forEach((info, time) => {
                currentData.push({ time, ...info });
            });

            // Remove old series
            chart.removeSeries(series);

            // Create new series (v4+ API)
            currentChartType = newType;
            if (newType === 'Candlestick') {
                series = chart.addSeries(LightweightCharts.CandlestickSeries);
                series.applyOptions({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                });
            } else {
                series = chart.addSeries(LightweightCharts.LineSeries);
                series.applyOptions({
                    color: '#2196F3',
                    lineWidth: 2,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: 4,
                });
            }

            // Restore markers
            updateVisibleMarkers();
        }

        // Signal to Swift that JavaScript is ready (all functions are defined)
        postMessage('pageLoaded', { success: true });
    </script>
</body>
</html>
